{"version":3,"file":"index.mjs","sources":["../src/utils/encode-form-uri-component.ts","../src/utils/match-groups.ts","../src/index.ts"],"sourcesContent":["/**\n * Encode a value into a URI component but escape spaces as `+`.\n *\n * @param value - The value to encode.\n */\nexport function encodeURIFormComponent(value: boolean | number | string) {\n  return encodeURIComponent(value).replace(/%20/g, \"+\")\n}\n","interface RegExpMatchArray<T extends Record<string, any>> {\n  /**\n   * An object of named capturing groups.\n   */\n  groups: T\n}\n\n/**\n * Safely access named capturing groups from a regular expression.\n *\n * @param string - The string against which to match the regular expression.\n * @param regex - The regular expression to match.\n */\nexport function matchGroups<T extends Record<string, any>>(\n  string: string,\n  regex: RegExp\n) {\n  const { groups } = (string.match(regex) ?? {}) as RegExpMatchArray<Partial<T>>\n\n  return groups ?? {}\n}\n","import {\n  AlbumMatch,\n  Entities,\n  Lookup,\n  LookupResponse,\n  Match,\n  Media,\n  Options,\n  ParseOptions,\n  PlainObject,\n  SearchOptions,\n  SearchResponse,\n  UrlMatch\n} from \"./types\"\nimport { encodeURIFormComponent } from \"./utils/encode-form-uri-component\"\nimport { matchGroups } from \"./utils/match-groups\"\n\nconst API = \"https://itunes.apple.com\"\n\nconst regex =\n  /^https?:\\/\\/(?<media>(?:apps|books|music|podcasts|))\\.apple\\.com\\/(?<country>[a-z]+)\\/(?<entity>[a-z-]+)/\nconst appRegex = /^https?:\\/\\/apps\\.apple\\.com\\/[^/]*\\/app\\/[^/]*\\/id(?<id>\\d+)/\nconst artistRegex =\n  /^https?:\\/\\/music\\.apple\\.com\\/[^/]*\\/artist\\/[^/]*\\/(?<id>\\d+)/\nconst audiobookRegex =\n  /^https?:\\/\\/books\\.apple\\.com\\/[^/]*\\/audiobook\\/[^/]*\\/id(?<id>\\d+)/\nconst authorRegex =\n  /^https?:\\/\\/books\\.apple\\.com\\/[^/]*\\/author\\/[^/]*\\/id(?<id>\\d+)/\nconst bookRegex =\n  /^https?:\\/\\/books\\.apple\\.com\\/[^/]*\\/book\\/[^/]*\\/id(?<id>\\d+)/\nconst musicVideoRegex =\n  /^https?:\\/\\/music\\.apple\\.com\\/[^/]*\\/music-video\\/[^/]*\\/(?<id>\\d+)/\nconst podcastRegex =\n  /^https?:\\/\\/podcasts\\.apple\\.com\\/[^/]*\\/podcast\\/[^/]*\\/id(?<id>\\d+)/\nconst albumRegex =\n  /^https?:\\/\\/music\\.apple\\.com\\/[^/]*\\/album\\/[^/]*\\/(?<id>\\d+)(?:\\?.*i=(?<trackId>\\d+))?/\n\nconst defaultOptions: Partial<Options> = {\n  country: \"us\"\n}\n\n/**\n * Query an endpoint from the iTunes Store API.\n *\n * @param endpoint - The API endpoint to query.\n * @param parameters - An object of URL parameters.\n */\nasync function query<T = PlainObject>(\n  endpoint: string,\n  parameters: Record<string, boolean | number | string>\n): Promise<T> {\n  const query = new URLSearchParams()\n\n  for (const [parameter, value] of Object.entries(parameters)) {\n    query.set(parameter, encodeURIFormComponent(value))\n  }\n\n  try {\n    const response = await fetch(`${API}/${endpoint}?${query.toString()}`)\n\n    if (response.ok) {\n      return await response.json()\n    } else {\n      throw new Error(response.statusText)\n    }\n  } catch (error) {\n    return Promise.reject(error)\n  }\n}\n\n/**\n * Parse and match a store catalog URL.\n *\n * @param url - The URL to parse and match.\n */\nfunction parse(url: string): Partial<ParseOptions> {\n  const { country, entity, media } = matchGroups<UrlMatch>(url, regex)\n\n  function getOptions(id?: string): Partial<ParseOptions> {\n    return id ? { country, id: Number(id) } : {}\n  }\n\n  function getMatchedOptions(regex: RegExp): Partial<ParseOptions> {\n    const { id } = matchGroups<Match>(url, regex)\n\n    return getOptions(id)\n  }\n\n  if (media === \"apps\") {\n    return getMatchedOptions(appRegex)\n  } else if (media === \"books\" && entity === \"audiobook\") {\n    return getMatchedOptions(audiobookRegex)\n  } else if (media === \"books\" && entity === \"author\") {\n    return getMatchedOptions(authorRegex)\n  } else if (media === \"books\" && entity === \"book\") {\n    return getMatchedOptions(bookRegex)\n  } else if (media === \"music\" && entity === \"artist\") {\n    return getMatchedOptions(artistRegex)\n  } else if (media === \"music\" && entity === \"music-video\") {\n    return getMatchedOptions(musicVideoRegex)\n  } else if (media === \"podcasts\" && entity === \"podcast\") {\n    return getMatchedOptions(podcastRegex)\n  } else if (media === \"music\" && entity === \"album\") {\n    const { id, trackId } = matchGroups<AlbumMatch>(url, albumRegex)\n\n    return trackId ? getOptions(trackId) : getOptions(id)\n  } else {\n    return {}\n  }\n}\n\n/**\n * Search within Apple's various store catalogs.\n *\n * @param search - A string to search for.\n * @param [options] - An optional set of settings.\n * @param [options.attribute] - Which attribute to search for, relative to the specified media type.\n * @param [options.country] - A two-letter country code where the queried store catalog will be from.\n * @param [options.entity] - The type of results returned, relative to the specified media type.\n * @param [options.explicit] - Whether to include explicit content.\n * @param [options.limit] - Limit the number of results.\n * @param [options.media] - The media type to search for.\n * @param [options.sort] - Whether to sort results by popularity or recentness.\n * @returns A promise fulfilling into the fetched results.\n *\n * @example\n *\n * ```js\n * const { results } = await search(\"Her\", {\n *   media: \"movie\"\n * })\n *\n * // results: [Result, Result, Result...]\n * ```\n */\nexport async function search<M extends Media, E extends Entities[M]>(\n  search: string,\n  options: Partial<SearchOptions<M, E>> = {}\n): Promise<SearchResponse<M, E>> {\n  const resolvedOptions = { ...defaultOptions, ...options }\n\n  return await query<SearchResponse<M, E>>(\"search\", {\n    ...resolvedOptions,\n    explicit: resolvedOptions.explicit ? \"Yes\" : \"No\",\n    term: search\n  })\n}\n\n/**\n * Look for a specific result within Apple's various store catalogs.\n *\n * @param type - The type of value to look for.\n * @param value - The value to look for.\n * @param [options] - An optional set of settings.\n * @param [options.country] - A two-letter country code where the queried store catalog will be from.\n * @returns A promise fulfilling into the fetched results.\n *\n * @example\n *\n * ```js\n * const { results } = await lookup(\n *   \"id\",\n *   \"https://music.apple.com/us/album/kim-jessie/1007596648?i=1007596731\"\n * )\n *\n * // results: [Result]\n * ```\n */\nexport async function lookup(\n  type: Lookup,\n  value: number,\n  options?: Partial<Options>\n): Promise<LookupResponse>\nexport async function lookup(\n  type: \"url\",\n  value: string,\n  options?: Partial<Options>\n): Promise<LookupResponse>\nexport async function lookup(\n  type: Lookup | \"url\",\n  value: number | string,\n  options: Partial<Options> = {}\n): Promise<LookupResponse> {\n  const resolvedOptions = { ...defaultOptions, ...options }\n  const resolvedValue = (\n    type === \"url\" ? parse(String(value)) : { [type]: value }\n  ) as Record<Exclude<Lookup, \"url\">, number | string>\n\n  return await query<LookupResponse>(\"lookup\", {\n    ...resolvedOptions,\n    ...resolvedValue\n  })\n}\n\nexport * from \"./types\"\n"],"names":["encodeURIFormComponent","value","encodeURIComponent","replace","matchGroups","string","regex","groups","match","appRegex","artistRegex","audiobookRegex","authorRegex","bookRegex","musicVideoRegex","podcastRegex","albumRegex","defaultOptions","country","async","query","endpoint","parameters","URLSearchParams","parameter","Object","entries","set","response","fetch","toString","ok","json","Error","statusText","error","Promise","reject","search","options","resolvedOptions","explicit","term","lookup","type","resolvedValue","url","entity","media","getOptions","id","Number","getMatchedOptions","trackId","parse","String"],"mappings":"61CAKgBA,EAAuBC,GACrC,OAAOC,mBAAmBD,GAAOE,QAAQ,OAAQ,cCOnCC,EACdC,EACAC,SAEA,MAAMC,OAAEA,YAAYF,EAAOG,MAAMF,MAAU,GAE3C,aAAOC,EAAAA,EAAU,GCFnB,MAEMD,iBACJ,iHACIG,iBAAW,8FACXC,iBACJ,gGACIC,iBACJ,qGACIC,iBACJ,kGACIC,iBACJ,gGACIC,iBACJ,wGACIC,iBACJ,sGACIC,iBACJ,4HAEIC,EAAmC,CACvCC,QAAS,MASXC,eAAeC,EACbC,EACAC,GAEA,MAAMF,EAAQ,IAAIG,gBAElB,IAAK,MAAOC,EAAWvB,KAAUwB,OAAOC,QAAQJ,GAC9CF,EAAMO,IAAIH,EAAWxB,EAAuBC,IAG9C,IACE,MAAM2B,QAAiBC,kCAAgBR,KAAYD,EAAMU,cAEzD,GAAIF,EAASG,GACX,aAAaH,EAASI,OAEtB,UAAUC,MAAML,EAASM,YAE3B,MAAOC,GACP,OAAOC,QAAQC,OAAOF,mBAqEJG,EACpBA,EACAC,EAAwC,IAExC,MAAMC,OAAuBvB,EAAmBsB,GAEhD,aAAanB,EAA4B,cACpCoB,GACHC,SAAUD,EAAgBC,SAAW,MAAQ,KAC7CC,KAAMJ,oBAkCYK,EACpBC,EACA3C,EACAsC,EAA4B,IAE5B,MAAMC,OAAuBvB,EAAmBsB,GAC1CM,EACK,QAATD,EA9GJ,SAAeE,GACb,MAAM5B,QAAEA,EAAF6B,OAAWA,EAAXC,MAAmBA,GAAU5C,EAAsB0C,EAAKxC,GAE9D,SAAS2C,EAAWC,GAClB,OAAOA,EAAK,CAAEhC,QAAAA,EAASgC,GAAIC,OAAOD,IAAQ,GAG5C,SAASE,EAAkB9C,GACzB,MAAM4C,GAAEA,GAAO9C,EAAmB0C,EAAKxC,GAEvC,OAAO2C,EAAWC,GAGpB,GAAc,SAAVF,EACF,OAAOI,EAAkB3C,MACN,UAAVuC,GAAgC,cAAXD,EAC9B,OAAOK,EAAkBzC,MACN,UAAVqC,GAAgC,WAAXD,EAC9B,OAAOK,EAAkBxC,MACN,UAAVoC,GAAgC,SAAXD,EAC9B,OAAOK,EAAkBvC,MACN,UAAVmC,GAAgC,WAAXD,EAC9B,OAAOK,EAAkB1C,MACN,UAAVsC,GAAgC,gBAAXD,EAC9B,OAAOK,EAAkBtC,MACN,aAAVkC,GAAmC,YAAXD,EACjC,OAAOK,EAAkBrC,MACN,UAAViC,GAAgC,UAAXD,EAAoB,CAClD,MAAMG,GAAEA,EAAFG,QAAMA,GAAYjD,EAAwB0C,EAAK9B,GAErD,OAAiBiC,EAAVI,GAA2CH,GAElD,MAAO,GA8EUI,CAAMC,OAAOtD,IAAU,CAAE2C,CAACA,GAAO3C,GAGpD,aAAamB,EAAsB,cAC9BoB,EACAK"}