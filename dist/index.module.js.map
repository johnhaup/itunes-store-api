{"version":3,"file":"index.module.js","sources":["../src/utils/match-groups.ts","../src/index.ts","../src/utils/encode-form-uri-component.ts"],"sourcesContent":["interface RegExpMatchArray<T extends Record<string, any>> {\n  /**\n   * An object of named capturing groups.\n   */\n  groups: T\n}\n\n/**\n * Safely access named capturing groups from a regular expression.\n *\n * @param string - The string against which to match the regular expression.\n * @param regex - The regular expression to match.\n */\nexport function matchGroups<T extends Record<string, any>>(\n  string: string,\n  regex: RegExp\n) {\n  const { groups } = (string.match(regex) ?? {}) as RegExpMatchArray<Partial<T>>\n\n  return groups ?? {}\n}\n","import {\n  AlbumMatch,\n  Entities,\n  Lookup,\n  LookupResponse,\n  Match,\n  Media,\n  Options,\n  ParseOptions,\n  PlainObject,\n  SearchOptions,\n  SearchResponse,\n  UrlMatch\n} from \"./types\"\nimport { encodeURIFormComponent } from \"./utils/encode-form-uri-component\"\nimport { matchGroups } from \"./utils/match-groups\"\n\nconst API = \"https://itunes.apple.com\"\n\nconst regex =\n  /^https?:\\/\\/(?<media>(?:apps|books|music|podcasts|))\\.apple\\.com\\/(?<country>[a-z]+)\\/(?<entity>[a-z-]+)/\nconst appRegex = /^https?:\\/\\/apps\\.apple\\.com\\/[^/]*\\/app\\/[^/]*\\/id(?<id>\\d+)/\nconst artistRegex =\n  /^https?:\\/\\/music\\.apple\\.com\\/[^/]*\\/artist\\/[^/]*\\/(?<id>\\d+)/\nconst audiobookRegex =\n  /^https?:\\/\\/books\\.apple\\.com\\/[^/]*\\/audiobook\\/[^/]*\\/id(?<id>\\d+)/\nconst authorRegex =\n  /^https?:\\/\\/books\\.apple\\.com\\/[^/]*\\/author\\/[^/]*\\/id(?<id>\\d+)/\nconst bookRegex =\n  /^https?:\\/\\/books\\.apple\\.com\\/[^/]*\\/book\\/[^/]*\\/id(?<id>\\d+)/\nconst musicVideoRegex =\n  /^https?:\\/\\/music\\.apple\\.com\\/[^/]*\\/music-video\\/[^/]*\\/(?<id>\\d+)/\nconst podcastRegex =\n  /^https?:\\/\\/podcasts\\.apple\\.com\\/[^/]*\\/podcast\\/[^/]*\\/id(?<id>\\d+)/\nconst albumRegex =\n  /^https?:\\/\\/music\\.apple\\.com\\/[^/]*\\/album\\/[^/]*\\/(?<id>\\d+)(?:\\?.*i=(?<trackId>\\d+))?/\n\nconst defaultOptions: Partial<Options> = {\n  country: \"us\"\n}\n\n/**\n * Query an endpoint from the iTunes Store API.\n *\n * @param endpoint - The API endpoint to query.\n * @param parameters - An object of URL parameters.\n */\nasync function query<T = PlainObject>(\n  endpoint: string,\n  parameters: Record<string, boolean | number | string>\n): Promise<T> {\n  const query = new URLSearchParams()\n\n  for (const [parameter, value] of Object.entries(parameters)) {\n    query.set(parameter, encodeURIFormComponent(value))\n  }\n\n  try {\n    const response = await fetch(`${API}/${endpoint}?${query.toString()}`)\n\n    if (response.ok) {\n      return await response.json()\n    } else {\n      throw new Error(response.statusText)\n    }\n  } catch (error) {\n    return Promise.reject(error)\n  }\n}\n\n/**\n * Parse and match a store catalog URL.\n *\n * @param url - The URL to parse and match.\n */\nfunction parse(url: string): Partial<ParseOptions> {\n  const { country, entity, media } = matchGroups<UrlMatch>(url, regex)\n\n  function getOptions(id?: string): Partial<ParseOptions> {\n    return id ? { country, id: Number(id) } : {}\n  }\n\n  function getMatchedOptions(regex: RegExp): Partial<ParseOptions> {\n    const { id } = matchGroups<Match>(url, regex)\n\n    return getOptions(id)\n  }\n\n  if (media === \"apps\") {\n    return getMatchedOptions(appRegex)\n  } else if (media === \"books\" && entity === \"audiobook\") {\n    return getMatchedOptions(audiobookRegex)\n  } else if (media === \"books\" && entity === \"author\") {\n    return getMatchedOptions(authorRegex)\n  } else if (media === \"books\" && entity === \"book\") {\n    return getMatchedOptions(bookRegex)\n  } else if (media === \"music\" && entity === \"artist\") {\n    return getMatchedOptions(artistRegex)\n  } else if (media === \"music\" && entity === \"music-video\") {\n    return getMatchedOptions(musicVideoRegex)\n  } else if (media === \"podcasts\" && entity === \"podcast\") {\n    return getMatchedOptions(podcastRegex)\n  } else if (media === \"music\" && entity === \"album\") {\n    const { id, trackId } = matchGroups<AlbumMatch>(url, albumRegex)\n\n    return trackId ? getOptions(trackId) : getOptions(id)\n  } else {\n    return {}\n  }\n}\n\n/**\n * Search within Apple's various store catalogs.\n *\n * @param search - A string to search for.\n * @param [options] - An optional set of settings.\n * @param [options.attribute] - Which attribute to search for, relative to the specified media type.\n * @param [options.country] - A two-letter country code where the queried store catalog will be from.\n * @param [options.entity] - The type of results returned, relative to the specified media type.\n * @param [options.explicit] - Whether to include explicit content.\n * @param [options.limit] - Limit the number of results.\n * @param [options.media] - The media type to search for.\n * @param [options.sort] - Whether to sort results by popularity or recentness.\n * @returns A promise fulfilling into the fetched results.\n *\n * @example\n *\n * ```js\n * const { results } = await search(\"Her\", {\n *   media: \"movie\"\n * })\n *\n * // results: [Result, Result, Result...]\n * ```\n */\nexport async function search<M extends Media, E extends Entities[M]>(\n  search: string,\n  options: Partial<SearchOptions<M, E>> = {}\n): Promise<SearchResponse<M, E>> {\n  const resolvedOptions = { ...defaultOptions, ...options }\n\n  return await query<SearchResponse<M, E>>(\"search\", {\n    ...resolvedOptions,\n    explicit: resolvedOptions.explicit ? \"Yes\" : \"No\",\n    term: search\n  })\n}\n\n/**\n * Look for a specific result within Apple's various store catalogs.\n *\n * @param type - The type of value to look for.\n * @param value - The value to look for.\n * @param [options] - An optional set of settings.\n * @param [options.country] - A two-letter country code where the queried store catalog will be from.\n * @returns A promise fulfilling into the fetched results.\n *\n * @example\n *\n * ```js\n * const { results } = await lookup(\n *   \"id\",\n *   \"https://music.apple.com/us/album/kim-jessie/1007596648?i=1007596731\"\n * )\n *\n * // results: [Result]\n * ```\n */\nexport async function lookup(\n  type: Lookup,\n  value: number,\n  options?: Partial<Options>\n): Promise<LookupResponse>\nexport async function lookup(\n  type: \"url\",\n  value: string,\n  options?: Partial<Options>\n): Promise<LookupResponse>\nexport async function lookup(\n  type: Lookup | \"url\",\n  value: number | string,\n  options: Partial<Options> = {}\n): Promise<LookupResponse> {\n  const resolvedOptions = { ...defaultOptions, ...options }\n  const resolvedValue = (\n    type === \"url\" ? parse(String(value)) : { [type]: value }\n  ) as Record<Exclude<Lookup, \"url\">, number | string>\n\n  return await query<LookupResponse>(\"lookup\", {\n    ...resolvedOptions,\n    ...resolvedValue\n  })\n}\n\nexport * from \"./types\"\n","/**\n * Encode a value into a URI component but escape spaces as `+`.\n *\n * @param value - The value to encode.\n */\nexport function encodeURIFormComponent(value: boolean | number | string) {\n  return encodeURIComponent(value).replace(/%20/g, \"+\")\n}\n"],"names":["matchGroups","string","regex","groups","match","lookup","type","value","options","resolvedOptions","defaultOptions","resolvedValue","url","country","entity","media","getOptions","id","Number","getMatchedOptions","appRegex","audiobookRegex","authorRegex","bookRegex","artistRegex","musicVideoRegex","podcastRegex","albumRegex","trackId","parse","String","query","search","explicit","term","endpoint","parameters","URLSearchParams","Object","entries","set","encodeURIComponent","replace","fetch","API","toString","response","ok","json","Error","statusText","error","Promise","reject"],"mappings":"61CAagBA,EACdC,EACAC,SAEQC,YAAYF,EAAOG,MAAMF,MAAU,IAAnCC,OAER,aAAOA,EAAAA,EAAU,GC+JGE,IAAAA,WACpBC,EACAC,EACAC,YAAAA,IAAAA,EAA4B,cAEtBC,OAAuBC,EAAmBF,GAC1CG,EACK,QAATL,EA9GJ,SAAeM,GACb,MAAmCZ,EAAsBY,EAAKV,GAAtDW,IAAAA,QAASC,IAAAA,OAAQC,IAAAA,MAEzB,SAASC,EAAWC,GAClB,OAAOA,EAAK,CAAEJ,QAAAA,EAASI,GAAIC,OAAOD,IAAQ,GAG5C,SAASE,EAAkBjB,GAGzB,OAAOc,EAFQhB,EAAmBY,EAAKV,GAA/Be,IAKV,GAAc,SAAVF,EACF,OAAOI,EAAkBC,MACN,UAAVL,GAAgC,cAAXD,EAC9B,OAAOK,EAAkBE,MACN,UAAVN,GAAgC,WAAXD,EAC9B,OAAOK,EAAkBG,MACN,UAAVP,GAAgC,SAAXD,EAC9B,OAAOK,EAAkBI,MACN,UAAVR,GAAgC,WAAXD,EAC9B,OAAOK,EAAkBK,MACN,UAAVT,GAAgC,gBAAXD,EAC9B,OAAOK,EAAkBM,MACN,aAAVV,GAAmC,YAAXD,EACjC,OAAOK,EAAkBO,MACN,UAAVX,GAAgC,UAAXD,EAAoB,CAClD,MAAwBd,EAAwBY,EAAKe,GAErD,OAAiBX,IAFLY,WAAJX,IAIR,MAAO,GA8EUY,CAAMC,OAAOvB,YAAaD,GAAOC,4BAGvCwB,EAAsB,cAC9BtB,EACAE,KAZP,oCA3CsBqB,WACpBA,EACAxB,YAAAA,IAAAA,EAAwC,QAExC,IAAMC,OAAuBC,EAAmBF,0BAEnCuB,EAA4B,cACpCtB,GACHwB,SAAUxB,EAAgBwB,SAAW,MAAQ,KAC7CC,KAAMF,MATV,oCAxFeD,WACbI,EACAC,OAIA,IAFA,IAAML,EAAQ,IAAIM,sBAEeC,OAAOC,QAAQH,kBAAa,CAAxD,WACHL,EAAMS,SChDDC,yBAA0BC,QAAQ,OAAQ,qEDoDxBC,MAASC,MAAOT,MAAYJ,EAAMc,2BAAnDC,MAEFA,EAASC,0BACED,EAASE,QAEtB,UAAUC,MAAMH,EAASI,mFAEpBC,GACP,OAAOC,QAAQC,OAAOF,0CAjDpBP,EAAM,2BAEN1C,iBACJ,iHACIkB,iBAAW,8FACXI,iBACJ,gGACIH,iBACJ,qGACIC,iBACJ,kGACIC,iBACJ,gGACIE,iBACJ,wGACIC,iBACJ,sGACIC,iBACJ,4HAEIjB,EAAmC,CACvCG,QAAS"}