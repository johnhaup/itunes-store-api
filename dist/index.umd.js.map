{"version":3,"file":"index.umd.js","sources":["../src/utils/match-groups.ts","../src/index.ts","../src/utils/encode-form-uri-component.ts"],"sourcesContent":["interface RegExpMatchArray<T extends Record<string, any>> {\n  /**\n   * An object of named capturing groups.\n   */\n  groups: T\n}\n\n/**\n * Safely access named capturing groups from a regular expression.\n *\n * @param string - The string against which to match the regular expression.\n * @param regex - The regular expression to match.\n */\nexport function matchGroups<T extends Record<string, any>>(\n  string: string,\n  regex: RegExp\n) {\n  const { groups } = (string.match(regex) ?? {}) as RegExpMatchArray<Partial<T>>\n\n  return groups ?? {}\n}\n","import {\n  AlbumMatch,\n  Entities,\n  Lookup,\n  LookupResponse,\n  Match,\n  Media,\n  Options,\n  ParseOptions,\n  PlainObject,\n  SearchOptions,\n  SearchResponse,\n  UrlMatch\n} from \"./types\"\nimport { encodeURIFormComponent } from \"./utils/encode-form-uri-component\"\nimport { matchGroups } from \"./utils/match-groups\"\n\nconst API = \"https://itunes.apple.com\"\n\nconst regex =\n  /^https?:\\/\\/(?<media>(?:apps|books|music|podcasts|))\\.apple\\.com\\/(?<country>[a-z]+)\\/(?<entity>[a-z-]+)/\nconst appRegex = /^https?:\\/\\/apps\\.apple\\.com\\/[^/]*\\/app\\/[^/]*\\/id(?<id>\\d+)/\nconst artistRegex =\n  /^https?:\\/\\/music\\.apple\\.com\\/[^/]*\\/artist\\/[^/]*\\/(?<id>\\d+)/\nconst audiobookRegex =\n  /^https?:\\/\\/books\\.apple\\.com\\/[^/]*\\/audiobook\\/[^/]*\\/id(?<id>\\d+)/\nconst authorRegex =\n  /^https?:\\/\\/books\\.apple\\.com\\/[^/]*\\/author\\/[^/]*\\/id(?<id>\\d+)/\nconst bookRegex =\n  /^https?:\\/\\/books\\.apple\\.com\\/[^/]*\\/book\\/[^/]*\\/id(?<id>\\d+)/\nconst musicVideoRegex =\n  /^https?:\\/\\/music\\.apple\\.com\\/[^/]*\\/music-video\\/[^/]*\\/(?<id>\\d+)/\nconst podcastRegex =\n  /^https?:\\/\\/podcasts\\.apple\\.com\\/[^/]*\\/podcast\\/[^/]*\\/id(?<id>\\d+)/\nconst albumRegex =\n  /^https?:\\/\\/music\\.apple\\.com\\/[^/]*\\/album\\/[^/]*\\/(?<id>\\d+)(?:\\?.*i=(?<trackId>\\d+))?/\n\nconst defaultOptions: Partial<Options> = {\n  country: \"us\"\n}\n\n/**\n * Query an endpoint from the iTunes Store API.\n *\n * @param endpoint - The API endpoint to query.\n * @param parameters - An object of URL parameters.\n */\nasync function query<T = PlainObject>(\n  endpoint: string,\n  parameters: Record<string, boolean | number | string>\n): Promise<T> {\n  const query = new URLSearchParams()\n\n  for (const [parameter, value] of Object.entries(parameters)) {\n    query.set(parameter, encodeURIFormComponent(value))\n  }\n\n  try {\n    const response = await fetch(`${API}/${endpoint}?${query.toString()}`)\n\n    if (response.ok) {\n      return await response.json()\n    } else {\n      throw new Error(response.statusText)\n    }\n  } catch (error) {\n    return Promise.reject(error)\n  }\n}\n\n/**\n * Parse and match a store catalog URL.\n *\n * @param url - The URL to parse and match.\n */\nfunction parse(url: string): Partial<ParseOptions> {\n  const { country, entity, media } = matchGroups<UrlMatch>(url, regex)\n\n  function getOptions(id?: string): Partial<ParseOptions> {\n    return id ? { country, id: Number(id) } : {}\n  }\n\n  function getMatchedOptions(regex: RegExp): Partial<ParseOptions> {\n    const { id } = matchGroups<Match>(url, regex)\n\n    return getOptions(id)\n  }\n\n  if (media === \"apps\") {\n    return getMatchedOptions(appRegex)\n  } else if (media === \"books\" && entity === \"audiobook\") {\n    return getMatchedOptions(audiobookRegex)\n  } else if (media === \"books\" && entity === \"author\") {\n    return getMatchedOptions(authorRegex)\n  } else if (media === \"books\" && entity === \"book\") {\n    return getMatchedOptions(bookRegex)\n  } else if (media === \"music\" && entity === \"artist\") {\n    return getMatchedOptions(artistRegex)\n  } else if (media === \"music\" && entity === \"music-video\") {\n    return getMatchedOptions(musicVideoRegex)\n  } else if (media === \"podcasts\" && entity === \"podcast\") {\n    return getMatchedOptions(podcastRegex)\n  } else if (media === \"music\" && entity === \"album\") {\n    const { id, trackId } = matchGroups<AlbumMatch>(url, albumRegex)\n\n    return trackId ? getOptions(trackId) : getOptions(id)\n  } else {\n    return {}\n  }\n}\n\n/**\n * Search within Apple's various store catalogs.\n *\n * @param search - A string to search for.\n * @param [options] - An optional set of settings.\n * @param [options.attribute] - Which attribute to search for, relative to the specified media type.\n * @param [options.country] - A two-letter country code where the queried store catalog will be from.\n * @param [options.entity] - The type of results returned, relative to the specified media type.\n * @param [options.explicit] - Whether to include explicit content.\n * @param [options.limit] - Limit the number of results.\n * @param [options.media] - The media type to search for.\n * @param [options.sort] - Whether to sort results by popularity or recentness.\n * @returns A promise fulfilling into the fetched results.\n *\n * @example\n *\n * ```js\n * const { results } = await search(\"Her\", {\n *   media: \"movie\"\n * })\n *\n * // results: [Result, Result, Result...]\n * ```\n */\nexport async function search<M extends Media, E extends Entities[M]>(\n  search: string,\n  options: Partial<SearchOptions<M, E>> = {}\n): Promise<SearchResponse<M, E>> {\n  const resolvedOptions = { ...defaultOptions, ...options }\n\n  return await query<SearchResponse<M, E>>(\"search\", {\n    ...resolvedOptions,\n    explicit: resolvedOptions.explicit ? \"Yes\" : \"No\",\n    term: search\n  })\n}\n\n/**\n * Look for a specific result within Apple's various store catalogs.\n *\n * @param type - The type of value to look for.\n * @param value - The value to look for.\n * @param [options] - An optional set of settings.\n * @param [options.country] - A two-letter country code where the queried store catalog will be from.\n * @returns A promise fulfilling into the fetched results.\n *\n * @example\n *\n * ```js\n * const { results } = await lookup(\n *   \"id\",\n *   \"https://music.apple.com/us/album/kim-jessie/1007596648?i=1007596731\"\n * )\n *\n * // results: [Result]\n * ```\n */\nexport async function lookup(\n  type: Lookup,\n  value: number,\n  options?: Partial<Options>\n): Promise<LookupResponse>\nexport async function lookup(\n  type: \"url\",\n  value: string,\n  options?: Partial<Options>\n): Promise<LookupResponse>\nexport async function lookup(\n  type: Lookup | \"url\",\n  value: number | string,\n  options: Partial<Options> = {}\n): Promise<LookupResponse> {\n  const resolvedOptions = { ...defaultOptions, ...options }\n  const resolvedValue = (\n    type === \"url\" ? parse(String(value)) : { [type]: value }\n  ) as Record<Exclude<Lookup, \"url\">, number | string>\n\n  return await query<LookupResponse>(\"lookup\", {\n    ...resolvedOptions,\n    ...resolvedValue\n  })\n}\n\nexport * from \"./types\"\n","/**\n * Encode a value into a URI component but escape spaces as `+`.\n *\n * @param value - The value to encode.\n */\nexport function encodeURIFormComponent(value: boolean | number | string) {\n  return encodeURIComponent(value).replace(/%20/g, \"+\")\n}\n"],"names":["matchGroups","string","regex","groups","match","lookup","query","endpoint","parameters","URLSearchParams","Object","entries","set","encodeURIComponent","replace","fetch","API","toString","response","ok","json","Error","statusText","error","Promise","reject","appRegex","artistRegex","audiobookRegex","authorRegex","bookRegex","musicVideoRegex","podcastRegex","albumRegex","defaultOptions","country","type","value","options","resolvedOptions","resolvedValue","url","entity","media","getOptions","id","Number","getMatchedOptions","trackId","parse","String","search","explicit","term"],"mappings":"qkDAagBA,EACdC,EACAC,SAEQC,YAAYF,EAAOG,MAAMF,MAAU,IAAnCC,OAER,aAAOA,EAAAA,EAAU,GC+JGE,IAnIPC,WACbC,EACAC,OAIA,IAFA,IAAMF,EAAQ,IAAIG,sBAEeC,OAAOC,QAAQH,kBAAa,CAAxD,WACHF,EAAMM,SChDDC,yBAA0BC,QAAQ,OAAQ,qEDoDxBC,MAASC,MAAOT,MAAYD,EAAMW,2BAAnDC,MAEFA,EAASC,0BACED,EAASE,QAEtB,UAAUC,MAAMH,EAASI,mFAEpBC,GACP,OAAOC,QAAQC,OAAOF,0CAjDpBP,EAAM,2BAENd,iBACJ,iHACIwB,iBAAW,8FACXC,iBACJ,gGACIC,iBACJ,qGACIC,iBACJ,kGACIC,iBACJ,gGACIC,iBACJ,wGACIC,iBACJ,sGACIC,iBACJ,4HAEIC,EAAmC,CACvCC,QAAS,wBA6ITC,EACAC,EACAC,YAAAA,IAAAA,EAA4B,cAEtBC,OAAuBL,EAAmBI,GAC1CE,EACK,QAATJ,EA9GJ,SAAeK,GACb,MAAmCzC,EAAsByC,EAAKvC,GAAtDiC,IAAAA,QAASO,IAAAA,OAAQC,IAAAA,MAEzB,SAASC,EAAWC,GAClB,OAAOA,EAAK,CAAEV,QAAAA,EAASU,GAAIC,OAAOD,IAAQ,GAG5C,SAASE,EAAkB7C,GAGzB,OAAO0C,EAFQ5C,EAAmByC,EAAKvC,GAA/B2C,IAKV,GAAc,SAAVF,EACF,OAAOI,EAAkBrB,MACN,UAAViB,GAAgC,cAAXD,EAC9B,OAAOK,EAAkBnB,MACN,UAAVe,GAAgC,WAAXD,EAC9B,OAAOK,EAAkBlB,MACN,UAAVc,GAAgC,SAAXD,EAC9B,OAAOK,EAAkBjB,MACN,UAAVa,GAAgC,WAAXD,EAC9B,OAAOK,EAAkBpB,MACN,UAAVgB,GAAgC,gBAAXD,EAC9B,OAAOK,EAAkBhB,MACN,aAAVY,GAAmC,YAAXD,EACjC,OAAOK,EAAkBf,MACN,UAAVW,GAAgC,UAAXD,EAAoB,CAClD,MAAwB1C,EAAwByC,EAAKR,GAErD,OAAiBW,IAFLI,WAAJH,IAIR,MAAO,GA8EUI,CAAMC,OAAOb,YAAaD,GAAOC,4BAGvC/B,EAAsB,cAC9BiC,EACAC,KAZP,sDA1CEW,EACAb,YAAAA,IAAAA,EAAwC,QAExC,IAAMC,OAAuBL,EAAmBI,0BAEnChC,EAA4B,cACpCiC,GACHa,SAAUb,EAAgBa,SAAW,MAAQ,KAC7CC,KAAMF,MATV"}